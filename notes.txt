DAY2
Data structure: Storing and arranging data in memory in some particular way so as to achieve some efficiency

ARRAY:
Array is a data structure where elements are stored in continous memory locations
Simplest DS and easy to use with help of subscript
Array is time efficient data structure
Array is space inefficient data structure
Accessing any unit in Array is BigO(1)

NOTE:
The DS to which we can apply subscript is called ordered DS

LINKED LISTS:
Linked list is space efficient data structure
Linked list is time inefficient data structure
Accessing any unit in Linked list is BigO(n)

Space time trade-off: Compromising one of the quantity for the other
----------------------------------------------------------------------------------------------
how exactly elements are stored is physical view
how exactly elements are seen is conceptual / logical view
----------------------------------------------------------------------------------------------
ARITHMETIC OPERATORS:
+ - * / // % **
I/P are numbers
O/P is number
All are binary operators
uses infix notation
ALl operators except ** have left to right associativity
5 + 5.5
Here 5 is implicity casted to float and then the addition is done.
The precedence of + and - is less than the other
what is evaluated first is the operator having highest precedence i.e., **
therefore precedence operator takes over the associativity
The infix notation expressions are converted to postfix and then evaluated
----------------------------------------------------------------------------------------------
1.convert infix expression to postfix
2.evaluate postfix expression
3.find Nth term of the series 1 2 2 3 3 5 5 7 8 11 13 13
Odd terms:  1 2 3 5  8  13 21(fibonaccci series)
Even terms: 2 3 5 7 11 13(prime series)
when n is odd print (n/2)+1th term from fibonaccci series
when n is even print (n/2)th term from prime series

4.Accept a number and find the next smallest possible bigger number that must have all digits as the input number. If such a number is not possible to be created then print not possible
i/p num stored in Array
re arrange the numbers and check if it is greater than the input number in a loop and store the smallest larger number in another variable
print the variable as output

Start from units place
Look for the next digit which is smaller than the current digit
Mark the position of the smallest digit
swap digits ( ?? )
Sort digits after the position in ?? order 
----------------------------------------------------------------------------------------------
Do we have a main function in python? 
Yes we have
the global code is implicity put into __main__()
----------------------------------------------------------------------------------------------
Stratergy used across in software industry is functional programming

----------------------------------------------------------------------------------------------
Notations:

Big-Oh (O):
1.Usually used to find worst case efficiency
2.Finds the efficiency on the i/p size (n)
3.However worst best and average(all 3) efficiency can be found
4.Its purpose is not to find the exact efficiency. Rather it is to find the ORDER in which the algorithm is.
Eg. linear,quadratic,factorial,square root,logarithmic etc 
5.It considers the input size 'n' to be very big. Thus it gives efficiency for large data.
6. Remove the constants from the efficiency to get only the order

----------------------------------------------------------------------------------------------
LINEAR SEARCH:
Number of elements as input: N 
best case efficiency (BCE): O(1)
worst case efficiency (WCE): O(n)
average case efficiency (ACE): O(n)
----------------------------------------------------------------------------------------------
BINARY SEARCH
Pre requisite: The elements in the DS must be sorted

Number of elements as input: N 
Let us assume the number of iterations: X
1st      2nd      3rd              last-2 last-1  last 
 N       N/2      N/4    ........    4       2     1
2(x-1)  2(x-2)  2(x-3)              2(2)   2(1)   2(0)

N = 2(x-1)
N = 2(x) (ignore -1)
X = Log(N)

best case efficiency (BCE): O(1)
worst case efficiency (WCE): O(Log(N))
average case efficiency (ACE):Log(N)
----------------------------------------------------------------------------------------------

Frame: A frame is a memory allocated to a function during runtime 
Special Purpose Registers
IR 
PC 
FP 
SP 
Accumilator
Function call Stack (System stack)

Technically End of Program is when stack pointer and frame pointer is null
During start of the program the frame pointer points to frame of main function
----------------------------------------------------------------------------------------------
Command Line Arguments
Passing data to the program from the command line 
$ python program_name.py
$ python program_name.py 10 20 30
here 10 20 30 are the command line arguments
However the script name itself(program_name) is also sent as one of the argument, precisely as the first argument
All arguments are always passed as strings
These arguments are stored by the OS in memory in an array and the reference(address) of the array is passed by the OS to the programmer which is copied to sys.argv
----------------------------------------------------------------------------------------------

python debugger

----------------------------------------------------------------------------------------------
DAY3

QUICK SORT
orange partitioning hacker-rank problem explanation with solution
1 2 3 4 5<-pivot
efficiency of partitioning: O(n)[because of the presence of for loop]
quick sort should be informed about the position of partitioning therefore it has to return the posisition[index] of the pivot
apply recursively


best case efficiency (BCE) : n*Log(n)
worst case efficiency (WCE) : O(n**2)
average case efficiency (ACE) : O(n*Log(n))  

NOTE: Lists are accessed in functions by call by reference
----------------------------------------------------------------------------------------------

Datatypes in Mysql:

numbers:   (relation in java)
tinyint     byte
smallint    short
int         int 
bigint      long
date 

varchar     string 
float       decimal number

Constraints:
check
default
unique
not null
auto increment
primary key
references

Table 1
person      
id          int             primary key     auto increment
name        varchar(64)     not null
age         tinyint         
location    varchar
gender      varchar(2)      check(regex) (user should enter m/f[case insensitive])

databases should be named in plural in sql
create table persons(id int primary key auto_increment, name varchar(32) not null, age tinyint, location varchar(32), gender varchar(1) check())auto_increment(101,2);

insert into persons(name, age, gender) values('nithin',40,'m')

Table 2
employee
id                  int             primary key     auto_increment
name                varchar(32)     not null
technology          varchar(32)
designation         varchar(32) 
salary              float           default(10000)
comission           float
phone_number        bigint          unique
date_of_joining     datetime        default getdate()
years_of_experience tinyint         not null


SQL 
DDL-Data defenition Language     create,alter,drop,truncate
DML-Data manipulation Language   insert,delete,update
TCL-Transaction control Language savepoint,commit,roleback
DRL-Data retreival Language      select
DCL-Data control Language        grant,control

1. print all the employee details who salary is below 1 lakh
select * from employees where salary<100000;

2. list employee name and designation whose name starts with A
select name,designation from employees where name like 'a%';

3. list name and ph.no. of the employees who havent got comission for this month
select name, phone_number from employees where comission is null;
(use this)
(checks if hte cell value of comission in the rwow is empty )

select name, phone_number from employees where comission = null;
(check the cell value in the table with the variable named null)

select name, phone_number from employees where comission = 'null';
(check the cell value in the table with the string literal(constant value) 'null')

4. delete all rows from the table
delete from employees;
(deletes the data in the table(all rows), but the auto_increment and meta data persists i.e., the new row gets the id, which is a continued value)

truncate table employees;
(deletes the data in the table(all rows),and the auto_increment but the meta data persists i.e., the new row added later will get id 1)

drop table employees;
(all data is deleted)

CRUD operations:
C create (insert) One record 
R Read/Retreive   One tuple
U Update          One row
D Delete          One row
List all rows

insert into employees(name,technology,designation,salary,comission,phone_number,date_of_joining,years_of_experience) values('yash','c','software tester',90000,2000,243453454,'2023-09-12',5);

select * from employees where id = 1;
update employees set salary = 145000 where id=1;
delete from employees where id = 5;
select * from employees;

These are the most frequently uesd operations.
In RestFul APIs, which uses the HTTP protocol,
We perform the following operations using the VERBS:
1. POST      for insert
2. GET       for Read/select
3. PUT/PATCH for update (with id)
4. DELETE    for delete (with id)
5. GET with  id for reading one

before grouping where
for grouping use group by
after grouping having

saved queries are known as views

tables for a club

members(id, name, wallet_bal,phone_number, dob, gender)

games(id,name,price_per_head, min_count, max_count, duration, description)

recharges(id,amount,mem_id,date)

Transactions(id,mem_id,amount,game_id)

collections(id,date,amount)

desc <tablename>;
provides metadata of the table

-----------------------------------------------------------------------------------------------

connect to Mysql from python
and perform the operations on the database 

hostname
portnumber
username
password
database
charset

-----------------------------------------------------------------------------------------------

DAY4:

Insertion Sort: Optimistic Sort
Technique is decrease and conquer

Insertion sort fails when the input array is very large

from 2nd element to last element of unsorted array:
    copy current element into element
    j = index of element -1
    i = index of last element in sorted array
    while j >= 0 and element < current element in sorted array:
        sorted_array[j+1] = sorted array[j]
        j--
    sorted_array[j+1] = element


for i in range (l,len(array)):
    j = i-1
    element = array[i]
    while j >= 0 and element < array[j]:
        array[j+1] = array[j]
        j--
    array[j+1] = element

1. Implement Insertion sort on case insensitive string
2. Find sum of odd placed even digits in a number

merge sort: stable sorting Technique
has same efficiency in all 3 scenarios

def merge_sort(numbers,low,high):
    if low < high:
        #mid = (low+high)//2
        mid = (low + (high - low ) // 2)
        merge_sort(numbers, low, mid-1)
        merge_sort(numbers,mid,high)
        merge(numbers,low,mid,high)

#while i < len(array1) and j < len(array2):

def merge(numbers, low, mid, high):
    copy 1st half of array to array1
    copy 2nd half of array to array2
    merged_array = []
    k = 0
    i = low
    j = mid
    while array1 and array2 has numbers:
        if array1[i] < array2[j]:
            merged_array[k] = array1[i]
            i+=1
        else:
            merged_array[k] = array2[j]
            j+=1
        k+=1
    merged_array += array1[i:]
    merged_array += array2[j:]
    

Bubble Sort
12 5  19 11  3 17  2 13  7
5  12 11  3 17  2 13  7 19
5  11  3 12  2 13  7  17
.
.
.
.
2  3  5  7 11 12 13 17 19
8+7+6+5+4+3+2+1 = No of comparisions
def optimal_bubble_sort:
    for i in range(len(array)-1):
        sorted = True
        for j in range(len(array)-i-1):
            if array [j] > array [j+1]
                array[j] , array[j+1=] = array[j+1], array[j]    
        if sorted:
            return   

Best case efficiency (BCE): O(n)
worst case efficiency (WCE): O(n**2)

Stacks and Queues using Lists